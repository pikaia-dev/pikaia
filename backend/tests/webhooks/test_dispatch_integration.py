"""
Integration tests for webhook dispatch flow.

Tests the end-to-end dispatch pipeline: outbox event creation, HMAC signing,
delivery with retry behavior, and billing webhook handlers with real DB writes.
"""

import time
from io import StringIO
from unittest.mock import MagicMock, patch

import httpx
import pytest
from django.core.management import call_command

from apps.billing.models import Subscription
from apps.billing.services import (
    handle_subscription_created,
    handle_subscription_deleted,
    handle_subscription_updated,
)
from apps.events.models import OutboxEvent
from apps.events.services import publish_event
from apps.webhooks.models import WebhookDelivery
from apps.webhooks.services import (
    DeliveryResult,
    WebhookDispatcher,
    dispatch_event_to_subscribers,
)
from apps.webhooks.signing import verify_signature

from ..accounts.factories import OrganizationFactory
from ..billing.factories import SubscriptionFactory
from .factories import WebhookDeliveryFactory, WebhookEndpointFactory


@pytest.mark.django_db
class TestOutboxEventCreationAndPickup:
    """Tests that outbox events are created and picked up by the publisher."""

    def test_publish_event_creates_outbox_entry(self) -> None:
        """Should persist an OutboxEvent with correct fields when publish_event is called."""
        org = OrganizationFactory.create()
        subscription = SubscriptionFactory.create(organization=org)

        event = publish_event(
            event_type="subscription.activated",
            aggregate=subscription,
            data={"stripe_subscription_id": "sub_test_1", "status": "active"},
            actor=None,
            organization_id=str(org.id),
        )

        assert event.status == OutboxEvent.Status.PENDING
        assert event.event_type == "subscription.activated"
        assert event.organization_id == str(org.id)
        assert event.aggregate_type == "subscription"
        assert event.aggregate_id == str(subscription.pk)
        assert event.payload is not None
        assert event.payload["event_type"] == "subscription.activated"

    def test_publish_events_command_marks_events_published(self) -> None:
        """The publish_events management command should mark pending events as published."""
        org = OrganizationFactory.create()
        subscription = SubscriptionFactory.create(organization=org)

        event = publish_event(
            event_type="subscription.activated",
            aggregate=subscription,
            data={"status": "active"},
            actor=None,
            organization_id=str(org.id),
        )

        assert event.status == OutboxEvent.Status.PENDING

        call_command("publish_events", "--once", stdout=StringIO())

        event.refresh_from_db()
        assert event.status == OutboxEvent.Status.PUBLISHED
        assert event.published_at is not None

    def test_multiple_events_published_in_order(self) -> None:
        """Multiple outbox events should be processed in creation order."""
        org = OrganizationFactory.create()
        subscription = SubscriptionFactory.create(organization=org)

        events = []
        for i in range(3):
            ev = publish_event(
                event_type=f"test.event_{i}",
                aggregate=subscription,
                data={"index": i},
                actor=None,
                organization_id=str(org.id),
            )
            events.append(ev)

        call_command("publish_events", "--once", stdout=StringIO())

        for ev in events:
            ev.refresh_from_db()
            assert ev.status == OutboxEvent.Status.PUBLISHED

    def test_already_published_events_are_skipped(self) -> None:
        """Events already marked as published should not be reprocessed."""
        org = OrganizationFactory.create()
        subscription = SubscriptionFactory.create(organization=org)

        event = publish_event(
            event_type="subscription.activated",
            aggregate=subscription,
            data={"status": "active"},
            actor=None,
            organization_id=str(org.id),
        )

        # Manually mark as published
        event.mark_published()
        original_published_at = event.published_at

        call_command("publish_events", "--once", stdout=StringIO())

        event.refresh_from_db()
        # published_at should not change since it was already published
        assert event.published_at == original_published_at


@pytest.mark.django_db
class TestHmacSignatureIntegration:
    """Tests HMAC signature computation through the full dispatch path."""

    def test_dispatcher_produces_verifiable_signature(self) -> None:
        """The signature generated by WebhookDispatcher should be verifiable."""
        endpoint = WebhookEndpointFactory.create()
        dispatcher = WebhookDispatcher()

        with patch.object(httpx.Client, "post") as mock_post:
            mock_response = MagicMock()
            mock_response.status_code = 200
            mock_response.text = '{"ok": true}'
            mock_post.return_value = mock_response

            result = dispatcher.dispatch(
                endpoint=endpoint,
                event_id="evt_hmac_test_1",
                event_type="member.created",
                event_data={"email": "test@example.com"},
                organization_id=str(endpoint.organization_id),
            )

        assert result.success is True
        assert result.signature.startswith("v1=")

        # Extract the payload and headers that were sent
        call_kwargs = mock_post.call_args.kwargs
        sent_payload = call_kwargs["content"]
        sent_headers = call_kwargs["headers"]

        # Verify the signature using the endpoint's secret
        timestamp = int(sent_headers["X-Webhook-Timestamp"])
        signature = sent_headers["X-Webhook-Signature"]
        assert verify_signature(sent_payload, endpoint.secret, signature, timestamp) is True

    def test_signature_rejects_tampered_payload(self) -> None:
        """A modified payload should fail signature verification."""
        endpoint = WebhookEndpointFactory.create()
        dispatcher = WebhookDispatcher()

        with patch.object(httpx.Client, "post") as mock_post:
            mock_response = MagicMock()
            mock_response.status_code = 200
            mock_response.text = ""
            mock_post.return_value = mock_response

            dispatcher.dispatch(
                endpoint=endpoint,
                event_id="evt_hmac_test_2",
                event_type="member.created",
                event_data={"email": "test@example.com"},
                organization_id=str(endpoint.organization_id),
            )

        call_kwargs = mock_post.call_args.kwargs
        sent_headers = call_kwargs["headers"]

        timestamp = int(sent_headers["X-Webhook-Timestamp"])
        signature = sent_headers["X-Webhook-Signature"]

        # Verify that a tampered payload is rejected
        tampered_payload = '{"tampered": true}'
        assert verify_signature(tampered_payload, endpoint.secret, signature, timestamp) is False

    def test_signature_rejects_wrong_secret(self) -> None:
        """A signature should fail verification with a different secret."""
        endpoint = WebhookEndpointFactory.create()
        dispatcher = WebhookDispatcher()

        with patch.object(httpx.Client, "post") as mock_post:
            mock_response = MagicMock()
            mock_response.status_code = 200
            mock_response.text = ""
            mock_post.return_value = mock_response

            dispatcher.dispatch(
                endpoint=endpoint,
                event_id="evt_hmac_test_3",
                event_type="member.created",
                event_data={"email": "test@example.com"},
                organization_id=str(endpoint.organization_id),
            )

        call_kwargs = mock_post.call_args.kwargs
        sent_payload = call_kwargs["content"]
        sent_headers = call_kwargs["headers"]

        timestamp = int(sent_headers["X-Webhook-Timestamp"])
        signature = sent_headers["X-Webhook-Signature"]

        wrong_secret = "whsec_totally_wrong_secret"
        assert verify_signature(sent_payload, wrong_secret, signature, timestamp) is False

    def test_different_endpoints_get_different_signatures(self) -> None:
        """Two endpoints with different secrets should produce different signatures."""
        org = OrganizationFactory.create()
        ep1 = WebhookEndpointFactory.create(organization=org, events=["member.created"])
        ep2 = WebhookEndpointFactory.create(organization=org, events=["member.created"])

        # Ensure they have different secrets
        assert ep1.secret != ep2.secret

        dispatcher = WebhookDispatcher()
        signatures = []

        for endpoint in [ep1, ep2]:
            with patch.object(httpx.Client, "post") as mock_post:
                mock_response = MagicMock()
                mock_response.status_code = 200
                mock_response.text = ""
                mock_post.return_value = mock_response

                dispatcher.dispatch(
                    endpoint=endpoint,
                    event_id="evt_same_event",
                    event_type="member.created",
                    event_data={"email": "test@example.com"},
                    organization_id=str(org.id),
                )

            call_kwargs = mock_post.call_args.kwargs
            signatures.append(call_kwargs["headers"]["X-Webhook-Signature"])

        assert signatures[0] != signatures[1]


@pytest.mark.django_db
class TestRetryBehaviorOnDeliveryFailure:
    """Tests retry scheduling and terminal failure handling in dispatch flow."""

    def test_failed_delivery_schedules_retry(self) -> None:
        """A delivery failure should increment attempt and schedule a retry."""
        org = OrganizationFactory.create()
        _endpoint = WebhookEndpointFactory.create(organization=org, events=["member.created"])

        with patch("apps.webhooks.services.WebhookDispatcher.dispatch") as mock_dispatch:
            mock_dispatch.return_value = DeliveryResult(
                success=False,
                http_status=500,
                duration_ms=200,
                response_snippet="Internal Server Error",
                error_type=WebhookDelivery.ErrorType.HTTP_ERROR,
                error_message="HTTP 500",
            )

            dispatch_event_to_subscribers(
                organization_id=str(org.id),
                event_id="evt_retry_test",
                event_type="member.created",
                event_data={"email": "test@example.com"},
            )

        delivery = WebhookDelivery.objects.get(event_id="evt_retry_test")
        assert delivery.status == WebhookDelivery.Status.PENDING
        assert delivery.attempt_number == 2
        assert delivery.next_retry_at is not None
        assert delivery.error_type == WebhookDelivery.ErrorType.HTTP_ERROR

    def test_terminal_failure_no_retry(self) -> None:
        """A 410 Gone response should mark delivery as permanently failed."""
        org = OrganizationFactory.create()
        _endpoint = WebhookEndpointFactory.create(organization=org, events=["member.created"])

        with patch("apps.webhooks.services.WebhookDispatcher.dispatch") as mock_dispatch:
            mock_dispatch.return_value = DeliveryResult(
                success=False,
                http_status=410,
                duration_ms=50,
                response_snippet="Gone",
                error_type=WebhookDelivery.ErrorType.HTTP_ERROR,
                error_message="HTTP 410",
            )

            dispatch_event_to_subscribers(
                organization_id=str(org.id),
                event_id="evt_terminal_test",
                event_type="member.created",
                event_data={},
            )

        delivery = WebhookDelivery.objects.get(event_id="evt_terminal_test")
        assert delivery.status == WebhookDelivery.Status.FAILURE
        assert delivery.next_retry_at is None

    def test_404_is_terminal_failure(self) -> None:
        """A 404 Not Found response should be treated as terminal."""
        org = OrganizationFactory.create()
        _endpoint = WebhookEndpointFactory.create(organization=org, events=["member.created"])

        with patch("apps.webhooks.services.WebhookDispatcher.dispatch") as mock_dispatch:
            mock_dispatch.return_value = DeliveryResult(
                success=False,
                http_status=404,
                duration_ms=30,
                response_snippet="Not Found",
                error_type=WebhookDelivery.ErrorType.HTTP_ERROR,
                error_message="HTTP 404",
            )

            dispatch_event_to_subscribers(
                organization_id=str(org.id),
                event_id="evt_404_test",
                event_type="member.created",
                event_data={},
            )

        delivery = WebhookDelivery.objects.get(event_id="evt_404_test")
        assert delivery.status == WebhookDelivery.Status.FAILURE
        assert delivery.next_retry_at is None

    def test_max_attempts_exhausted_marks_permanent_failure(self) -> None:
        """After max attempts, delivery should be permanently failed."""
        endpoint = WebhookEndpointFactory.create(events=["member.created"])

        # Create a delivery already at max attempts
        delivery = WebhookDeliveryFactory.create(
            endpoint=endpoint,
            event_id="evt_max_attempts",
            attempt_number=WebhookDelivery.MAX_ATTEMPTS,
        )

        delivery.mark_failure(
            error_type=WebhookDelivery.ErrorType.TIMEOUT,
            error_message="Request timed out",
        )

        delivery.refresh_from_db()
        assert delivery.status == WebhookDelivery.Status.FAILURE
        assert delivery.next_retry_at is None

    def test_retry_delays_increase_with_attempts(self) -> None:
        """Each successive retry should schedule a later next_retry_at."""
        endpoint = WebhookEndpointFactory.create(events=["member.created"])

        retry_times = []
        for attempt in range(1, 4):
            delivery = WebhookDeliveryFactory.create(
                endpoint=endpoint,
                event_id=f"evt_delay_{attempt}",
                attempt_number=attempt,
            )

            delivery.mark_failure(
                error_type=WebhookDelivery.ErrorType.CONNECTION_ERROR,
                error_message="Connection refused",
            )

            delivery.refresh_from_db()
            if delivery.next_retry_at is not None:
                retry_times.append(delivery.next_retry_at)

        # Each retry should be scheduled further out
        assert len(retry_times) == 3
        assert retry_times[0] < retry_times[1] < retry_times[2]

    def test_successful_delivery_resets_endpoint_failures(self) -> None:
        """A successful delivery should reset the endpoint consecutive_failures counter."""
        org = OrganizationFactory.create()
        endpoint = WebhookEndpointFactory.create(
            organization=org,
            events=["member.created"],
            consecutive_failures=5,
        )

        with patch("apps.webhooks.services.WebhookDispatcher.dispatch") as mock_dispatch:
            mock_dispatch.return_value = DeliveryResult(
                success=True,
                http_status=200,
                duration_ms=100,
                response_snippet='{"ok": true}',
                signature="v1=test",
            )

            dispatch_event_to_subscribers(
                organization_id=str(org.id),
                event_id="evt_success_reset",
                event_type="member.created",
                event_data={},
            )

        endpoint.refresh_from_db()
        assert endpoint.consecutive_failures == 0
        assert endpoint.last_delivery_status == "success"

    def test_failed_delivery_increments_endpoint_failures(self) -> None:
        """A failed delivery should increment the endpoint consecutive_failures counter."""
        org = OrganizationFactory.create()
        endpoint = WebhookEndpointFactory.create(
            organization=org,
            events=["member.created"],
            consecutive_failures=2,
        )

        with patch("apps.webhooks.services.WebhookDispatcher.dispatch") as mock_dispatch:
            mock_dispatch.return_value = DeliveryResult(
                success=False,
                http_status=500,
                duration_ms=100,
                response_snippet="error",
                error_type=WebhookDelivery.ErrorType.HTTP_ERROR,
                error_message="HTTP 500",
            )

            dispatch_event_to_subscribers(
                organization_id=str(org.id),
                event_id="evt_failure_increment",
                event_type="member.created",
                event_data={},
            )

        endpoint.refresh_from_db()
        assert endpoint.consecutive_failures == 3
        assert endpoint.last_delivery_status == "failure"

    def test_timeout_failure_is_retryable(self) -> None:
        """A timeout should be retried (not terminal)."""
        org = OrganizationFactory.create()
        _endpoint = WebhookEndpointFactory.create(organization=org, events=["member.created"])

        with patch("apps.webhooks.services.WebhookDispatcher.dispatch") as mock_dispatch:
            mock_dispatch.return_value = DeliveryResult(
                success=False,
                http_status=None,
                duration_ms=30000,
                response_snippet="",
                error_type=WebhookDelivery.ErrorType.TIMEOUT,
                error_message="Request timed out after 30s",
            )

            dispatch_event_to_subscribers(
                organization_id=str(org.id),
                event_id="evt_timeout_retry",
                event_type="member.created",
                event_data={},
            )

        delivery = WebhookDelivery.objects.get(event_id="evt_timeout_retry")
        assert delivery.status == WebhookDelivery.Status.PENDING
        assert delivery.attempt_number == 2
        assert delivery.next_retry_at is not None


@pytest.mark.django_db
class TestBillingWebhookHandlersIntegration:
    """Tests billing webhook handlers with real database operations."""

    def _build_stripe_subscription(
        self,
        sub_id: str,
        org_id: str,
        status: str = "active",
        price_id: str = "price_test_1",
        quantity: int = 5,
        period_start: int | None = None,
        period_end: int | None = None,
    ) -> dict:
        """Build a realistic Stripe subscription object."""
        now = int(time.time())
        return {
            "id": sub_id,
            "status": status,
            "metadata": {"organization_id": org_id},
            "items": {
                "data": [
                    {
                        "price": {"id": price_id},
                        "quantity": quantity,
                    }
                ]
            },
            "current_period": {
                "start": period_start or now,
                "end": period_end or (now + 30 * 86400),
            },
            "cancel_at_period_end": False,
        }

    @patch("apps.billing.services.publish_event")
    def test_handle_subscription_created_creates_record(self, mock_publish: MagicMock) -> None:
        """Should create a Subscription record from Stripe webhook data."""
        org = OrganizationFactory.create()
        stripe_sub = self._build_stripe_subscription(
            sub_id="sub_integration_1",
            org_id=str(org.id),
            status="active",
            quantity=5,
        )

        handle_subscription_created(stripe_sub)

        subscription = Subscription.objects.get(stripe_subscription_id="sub_integration_1")
        assert subscription.organization_id == org.id
        assert subscription.status == "active"
        assert subscription.quantity == 5
        assert subscription.stripe_price_id == "price_test_1"
        assert subscription.cancel_at_period_end is False

    @patch("apps.billing.services.publish_event")
    def test_handle_subscription_created_is_idempotent(self, mock_publish: MagicMock) -> None:
        """Calling handle_subscription_created twice should update, not duplicate."""
        org = OrganizationFactory.create()
        stripe_sub = self._build_stripe_subscription(
            sub_id="sub_idempotent_1",
            org_id=str(org.id),
            status="active",
            quantity=3,
        )

        handle_subscription_created(stripe_sub)
        handle_subscription_created(stripe_sub)

        assert Subscription.objects.filter(stripe_subscription_id="sub_idempotent_1").count() == 1

    @patch("apps.billing.services.publish_event")
    def test_handle_subscription_created_missing_org_metadata(
        self, mock_publish: MagicMock
    ) -> None:
        """Should gracefully skip when organization_id metadata is missing."""
        stripe_sub = {
            "id": "sub_no_org",
            "status": "active",
            "metadata": {},
            "items": {"data": []},
            "current_period": {},
            "cancel_at_period_end": False,
        }

        # Should not raise
        handle_subscription_created(stripe_sub)

        assert not Subscription.objects.filter(stripe_subscription_id="sub_no_org").exists()

    @patch("apps.billing.services.publish_event")
    def test_handle_subscription_updated_changes_status(self, mock_publish: MagicMock) -> None:
        """Should update subscription status from webhook data."""
        org = OrganizationFactory.create()
        subscription = SubscriptionFactory.create(
            organization=org,
            stripe_subscription_id="sub_update_1",
            status=Subscription.Status.ACTIVE,
            quantity=3,
        )

        stripe_sub = self._build_stripe_subscription(
            sub_id="sub_update_1",
            org_id=str(org.id),
            status="past_due",
            quantity=5,
        )

        handle_subscription_updated(stripe_sub)

        subscription.refresh_from_db()
        assert subscription.status == "past_due"
        assert subscription.quantity == 5

    @patch("apps.billing.services.publish_event")
    def test_handle_subscription_updated_emits_event_on_change(
        self, mock_publish: MagicMock
    ) -> None:
        """Should emit subscription.updated event when status changes."""
        org = OrganizationFactory.create()
        _subscription = SubscriptionFactory.create(
            organization=org,
            stripe_subscription_id="sub_event_1",
            status=Subscription.Status.ACTIVE,
            quantity=3,
        )

        stripe_sub = self._build_stripe_subscription(
            sub_id="sub_event_1",
            org_id=str(org.id),
            status="past_due",
            quantity=3,
        )

        handle_subscription_updated(stripe_sub)

        mock_publish.assert_called()
        call_kwargs = mock_publish.call_args.kwargs
        assert call_kwargs["event_type"] == "subscription.updated"
        assert call_kwargs["data"]["old_status"] == "active"
        assert call_kwargs["data"]["new_status"] == "past_due"

    @patch("apps.billing.services.publish_event")
    def test_handle_subscription_updated_no_event_when_unchanged(
        self, mock_publish: MagicMock
    ) -> None:
        """Should not emit event when status and quantity are unchanged."""
        org = OrganizationFactory.create()
        _subscription = SubscriptionFactory.create(
            organization=org,
            stripe_subscription_id="sub_noop_1",
            status=Subscription.Status.ACTIVE,
            quantity=5,
        )

        stripe_sub = self._build_stripe_subscription(
            sub_id="sub_noop_1",
            org_id=str(org.id),
            status="active",
            quantity=5,
        )

        handle_subscription_updated(stripe_sub)

        mock_publish.assert_not_called()

    @patch("apps.billing.services.publish_event")
    def test_handle_subscription_updated_creates_if_not_exists(
        self, mock_publish: MagicMock
    ) -> None:
        """Should fall back to creating subscription if it doesn't exist yet."""
        org = OrganizationFactory.create()

        stripe_sub = self._build_stripe_subscription(
            sub_id="sub_create_fallback",
            org_id=str(org.id),
            status="active",
            quantity=2,
        )

        handle_subscription_updated(stripe_sub)

        subscription = Subscription.objects.get(stripe_subscription_id="sub_create_fallback")
        assert subscription.status == "active"
        assert subscription.quantity == 2

    @patch("apps.billing.services.publish_event")
    def test_handle_subscription_deleted_cancels_subscription(
        self, mock_publish: MagicMock
    ) -> None:
        """Should mark subscription as canceled."""
        org = OrganizationFactory.create()
        subscription = SubscriptionFactory.create(
            organization=org,
            stripe_subscription_id="sub_delete_1",
            status=Subscription.Status.ACTIVE,
        )

        stripe_sub = {"id": "sub_delete_1"}

        handle_subscription_deleted(stripe_sub)

        subscription.refresh_from_db()
        assert subscription.status == Subscription.Status.CANCELED

    @patch("apps.billing.services.publish_event")
    def test_handle_subscription_deleted_emits_canceled_event(
        self, mock_publish: MagicMock
    ) -> None:
        """Should emit subscription.canceled event."""
        org = OrganizationFactory.create()
        _subscription = SubscriptionFactory.create(
            organization=org,
            stripe_subscription_id="sub_cancel_event",
            status=Subscription.Status.ACTIVE,
        )

        handle_subscription_deleted({"id": "sub_cancel_event"})

        mock_publish.assert_called_once()
        call_kwargs = mock_publish.call_args.kwargs
        assert call_kwargs["event_type"] == "subscription.canceled"

    @patch("apps.billing.services.publish_event")
    def test_handle_subscription_deleted_nonexistent_is_noop(self, mock_publish: MagicMock) -> None:
        """Should gracefully handle deletion of non-existent subscription."""
        handle_subscription_deleted({"id": "sub_does_not_exist"})

        mock_publish.assert_not_called()

    @patch("apps.billing.services.publish_event")
    def test_full_subscription_lifecycle(self, mock_publish: MagicMock) -> None:
        """Should handle create -> update -> cancel lifecycle via webhook handlers."""
        org = OrganizationFactory.create()

        # Step 1: Create
        stripe_sub = self._build_stripe_subscription(
            sub_id="sub_lifecycle_1",
            org_id=str(org.id),
            status="active",
            quantity=1,
        )
        handle_subscription_created(stripe_sub)

        subscription = Subscription.objects.get(stripe_subscription_id="sub_lifecycle_1")
        assert subscription.status == "active"
        assert subscription.quantity == 1

        # Step 2: Update (add seats)
        stripe_sub["status"] = "active"
        stripe_sub["items"]["data"][0]["quantity"] = 10
        handle_subscription_updated(stripe_sub)

        subscription.refresh_from_db()
        assert subscription.quantity == 10

        # Step 3: Cancel
        handle_subscription_deleted({"id": "sub_lifecycle_1"})

        subscription.refresh_from_db()
        assert subscription.status == Subscription.Status.CANCELED
