name: Deploy Backend to AWS ECS

on:
  push:
    branches: ["main"]
    paths:
      - 'backend/**'
      - 'emails/**'
      - 'infra/**'
      - '.github/workflows/deploy-ecs.yml'
  workflow_dispatch:

concurrency:
  group: deploy-backend
  cancel-in-progress: true

permissions:
  contents: read
  id-token: write

env:
  AWS_REGION: ${{ vars.AWS_REGION }}
  ECR_REPOSITORY: ${{ vars.ECR_REPOSITORY }}
  ECS_CLUSTER: ${{ vars.ECS_CLUSTER }}
  ECS_SERVICE: ${{ vars.ECS_SERVICE }}
  ECS_TASK_DEFINITION: ${{ vars.ECS_TASK_DEFINITION }}
  ECS_SUBNETS: ${{ vars.ECS_SUBNETS }}
  ECS_SECURITY_GROUPS: ${{ vars.ECS_SECURITY_GROUPS }}

jobs:
  # Detect which paths changed to determine deployment strategy
  changes:
    runs-on: ubuntu-latest
    outputs:
      infra: ${{ steps.filter.outputs.infra }}
      backend: ${{ steps.filter.outputs.backend }}
    steps:
      - uses: actions/checkout@v4
      - uses: dorny/paths-filter@v3
        id: filter
        with:
          filters: |
            infra:
              - 'infra/**'
            backend:
              - 'backend/**'
              - 'emails/**'

  deploy:
    needs: changes
    runs-on: ubuntu-latest
    environment: demo

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-region: ${{ env.AWS_REGION }}
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      # Build and push Docker image when backend files change
      - name: Build and push Docker image
        if: needs.changes.outputs.backend == 'true'
        env:
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -f backend/Dockerfile -t "${ECR_REPOSITORY}:${IMAGE_TAG}" -t "${ECR_REPOSITORY}:latest" backend/
          docker push "${ECR_REPOSITORY}:${IMAGE_TAG}"
          docker push "${ECR_REPOSITORY}:latest"

      # Run CDK deploy when infra files change (updates task definition, IAM, etc.)
      - name: Setup Python for CDK
        if: needs.changes.outputs.infra == 'true'
        uses: actions/setup-python@v5
        with:
          python-version: '3.14'

      - name: Setup Node.js for CDK
        if: needs.changes.outputs.infra == 'true'
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install uv
        if: needs.changes.outputs.infra == 'true'
        uses: astral-sh/setup-uv@v5
        with:
          version: "0.5.x"

      - name: Validate audit schema
        if: needs.changes.outputs.infra == 'true'
        working-directory: backend
        run: |
          uv sync
          uv run python manage.py generate_audit_schema --check

      - name: Install CDK and deploy infrastructure
        if: needs.changes.outputs.infra == 'true'
        working-directory: infra
        run: |
          npm install -g aws-cdk
          uv sync
          uv run cdk deploy TangoMedia TangoApp TangoEvents TangoObservability --require-approval never

      # Update ECS task definition when backend changes but not infra
      # (CDK deploy already handles this when infra changes)
      - name: Prepare and register new task definition revision
        if: needs.changes.outputs.backend == 'true' && needs.changes.outputs.infra != 'true'
        id: td
        env:
          NEW_IMAGE: ${{ vars.ECR_REPOSITORY }}:${{ github.sha }}
        run: |
          set -euo pipefail

          aws ecs describe-task-definition \
            --task-definition "${ECS_TASK_DEFINITION}" \
            --query 'taskDefinition' \
            --output json > td.json

          jq --arg IMAGE "${NEW_IMAGE}" '
            .containerDefinitions |= map(.image=$IMAGE)
            | del(.revision, .status, .taskDefinitionArn, .requiresAttributes, .compatibilities, .registeredAt, .registeredBy)
          ' td.json > td-updated.json

          aws ecs register-task-definition \
            --cli-input-json file://td-updated.json \
            --output json > td-registered.json

          NEW_TD_ARN=$(jq -r '.taskDefinition.taskDefinitionArn' td-registered.json)
          echo "taskDefinitionArn=${NEW_TD_ARN}" >> "$GITHUB_OUTPUT"

      - name: Update ECS service (backend-only changes)
        if: needs.changes.outputs.backend == 'true' && needs.changes.outputs.infra != 'true'
        run: |
          aws ecs update-service \
            --cluster "${ECS_CLUSTER}" \
            --service "${ECS_SERVICE}" \
            --task-definition "${{ steps.td.outputs.taskDefinitionArn }}" \
            --force-new-deployment \
            --output json > service-update.json

          aws ecs wait services-stable \
            --cluster "${ECS_CLUSTER}" \
            --services "${ECS_SERVICE}"

      # Force new deployment after CDK to pick up changes
      - name: Force new deployment (infra changes)
        if: needs.changes.outputs.infra == 'true'
        run: |
          aws ecs update-service \
            --cluster "${ECS_CLUSTER}" \
            --service "${ECS_SERVICE}" \
            --force-new-deployment \
            --output json > service-update.json

          aws ecs wait services-stable \
            --cluster "${ECS_CLUSTER}" \
            --services "${ECS_SERVICE}"

      # Always run migrations
      - name: Get task definition for migrations
        id: get-td
        run: |
          TD_ARN=$(aws ecs describe-services \
            --cluster "${ECS_CLUSTER}" \
            --services "${ECS_SERVICE}" \
            --query 'services[0].taskDefinition' \
            --output text)
          echo "taskDefinitionArn=${TD_ARN}" >> "$GITHUB_OUTPUT"
          
          MIGRATE_CONTAINER=$(aws ecs describe-task-definition \
            --task-definition "${TD_ARN}" \
            --query 'taskDefinition.containerDefinitions[0].name' \
            --output text)
          echo "migrateContainer=${MIGRATE_CONTAINER}" >> "$GITHUB_OUTPUT"

      - name: Create cache table
        run: |
          aws ecs run-task \
            --cluster "${ECS_CLUSTER}" \
            --launch-type FARGATE \
            --task-definition "${{ steps.get-td.outputs.taskDefinitionArn }}" \
            --network-configuration "awsvpcConfiguration={subnets=[${ECS_SUBNETS}],securityGroups=[${ECS_SECURITY_GROUPS}],assignPublicIp=DISABLED}" \
            --count 1 \
            --overrides "{\"containerOverrides\":[{\"name\":\"${{ steps.get-td.outputs.migrateContainer }}\",\"command\":[\"python\",\"manage.py\",\"createcachetable\"]}]}" \
            --output json > cache-table-run.json

      - name: Run Django migrations
        run: |
          aws ecs run-task \
            --cluster "${ECS_CLUSTER}" \
            --launch-type FARGATE \
            --task-definition "${{ steps.get-td.outputs.taskDefinitionArn }}" \
            --network-configuration "awsvpcConfiguration={subnets=[${ECS_SUBNETS}],securityGroups=[${ECS_SECURITY_GROUPS}],assignPublicIp=DISABLED}" \
            --count 1 \
            --overrides "{\"containerOverrides\":[{\"name\":\"${{ steps.get-td.outputs.migrateContainer }}\",\"command\":[\"python\",\"manage.py\",\"migrate\"]}]}" \
            --output json > migrations-run.json
